{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction MCCoroutine is a library, which adds extensive support for Kotlin Coroutines for Minecraft Server environments. Plugins for game servers and proxy servers often need to perform asynchronous operations (e.g. accessing databases) to be scalable for a large amount of players. MCCoroutine brings the full power of Kotlin Coroutines to them by extending the existing APIs with suspendable commands, events and schedules. Kotlin Coroutines Asynchronous or non-blocking programming is the new reality. Whether we're creating server-side, desktop or mobile applications, it's important that we provide an experience that is not only fluid from the user's perspective, but scalable when needed. There are many approaches to this problem, and in Kotlin we take a very flexible one by providing Coroutine support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy. Source: (https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/coroutines-overview.md, Date: [09/11/2018], Licence copied to LICENCE). Supported Game Servers: Spigot Paper CraftBukkit SpongeVanilla SpongeForge Supported Proxies: BungeeCord Waterfall Velocity Features Full implementation of Kotlin Coroutines for Minecraft Servers and Minecraft Proxies Extension functions for already established functions Connection to events, commands, schedulers Coroutine LifeCycle scope for plugins (supports plugin reloading) No NMS Support for Minecraft 1.7 - Latest Support for Java 8 - Latest","title":"Introduction"},{"location":"#introduction","text":"MCCoroutine is a library, which adds extensive support for Kotlin Coroutines for Minecraft Server environments. Plugins for game servers and proxy servers often need to perform asynchronous operations (e.g. accessing databases) to be scalable for a large amount of players. MCCoroutine brings the full power of Kotlin Coroutines to them by extending the existing APIs with suspendable commands, events and schedules. Kotlin Coroutines Asynchronous or non-blocking programming is the new reality. Whether we're creating server-side, desktop or mobile applications, it's important that we provide an experience that is not only fluid from the user's perspective, but scalable when needed. There are many approaches to this problem, and in Kotlin we take a very flexible one by providing Coroutine support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy. Source: (https://github.com/JetBrains/kotlin-web-site/blob/master/pages/docs/reference/coroutines-overview.md, Date: [09/11/2018], Licence copied to LICENCE). Supported Game Servers: Spigot Paper CraftBukkit SpongeVanilla SpongeForge Supported Proxies: BungeeCord Waterfall Velocity","title":"Introduction"},{"location":"#features","text":"Full implementation of Kotlin Coroutines for Minecraft Servers and Minecraft Proxies Extension functions for already established functions Connection to events, commands, schedulers Coroutine LifeCycle scope for plugins (supports plugin reloading) No NMS Support for Minecraft 1.7 - Latest Support for Java 8 - Latest","title":"Features"},{"location":"bridge/","text":"Suspending API Functions This page explains how you can switch into a suspendable scope anywhere in your plugin. Plugin launch Use the extension method plugin.launch{} to enter a suspendable context on any thread. plugin.launch{} is threadsafe and can be called from any thread at any time. This function also accepts two optional parameters context: CoroutineContext and start: CoroutineStart . It is not recommend changing them because it is very likely to make mistakes here. It requires a very deep understanding of Java threads, Java thread pools, Kotlin Coroutines and how each minecraft framework uses schedulers to dispatch tasks correctly when using other parameters. The default parameters are almost always correct. import com.github.shynixn.mccoroutine.bukkit.launch import kotlinx.coroutines.delay import org.bukkit.plugin.Plugin class Foo ( private val plugin : Plugin ) { fun bar () { val job = plugin . launch { delay ( 1000 ) bob () } } private suspend fun bob (){ } } Plugin launch execution order It is recommended to use suspendable command executors or suspendable listeners to switch to suspend functions. However, if you use plugin.launch , it is important to understand the execution order. Bukkit and Sponge BungeeCord and Velocity class Foo ( private val plugin : Plugin ) { fun bar () { // Main Thread println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is not suspended when switched to the same suspendable context. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first\" \"I am second\" \"I am third\" \"I am fourth\" \"I am fifth\" As BungeeCord and Velocity do not have a main thread, the execution order is slightly different. class Foo ( private val plugin : Plugin ) { fun bar () { // Any thread println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is suspended because it is not known which context was present before. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first\" \"I am third\" \"I am second\" \"I am fourth\" \"I am fifth\" You can actually change this behaviour by passing a different parameter to start . This might be useful for other libraries wanting to use MCCoroutine. class Foo ( private val plugin : Plugin ) { fun bar () { // Any thread println ( \"I am first\" ) val job = plugin . launch ( start = CoroutineStart . UNDISPATCHED ) { println ( \"I am second\" ) // The context is not suspended because start is undispatched. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first\" \"I am second\" \"I am third\" \"I am fourth\" \"I am fifth\" Do not use runBlocking Using runBlocking in production code is very bad as it annihilates any improvements, we have made by using coroutines. MCCoroutine manipulates the Bukkit Scheduler to allow runBlocking during startup and disable, but plugin.launch{} is almost always the function you want to use instead.","title":"Suspending API Functions"},{"location":"bridge/#suspending-api-functions","text":"This page explains how you can switch into a suspendable scope anywhere in your plugin.","title":"Suspending API Functions"},{"location":"bridge/#plugin-launch","text":"Use the extension method plugin.launch{} to enter a suspendable context on any thread. plugin.launch{} is threadsafe and can be called from any thread at any time. This function also accepts two optional parameters context: CoroutineContext and start: CoroutineStart . It is not recommend changing them because it is very likely to make mistakes here. It requires a very deep understanding of Java threads, Java thread pools, Kotlin Coroutines and how each minecraft framework uses schedulers to dispatch tasks correctly when using other parameters. The default parameters are almost always correct. import com.github.shynixn.mccoroutine.bukkit.launch import kotlinx.coroutines.delay import org.bukkit.plugin.Plugin class Foo ( private val plugin : Plugin ) { fun bar () { val job = plugin . launch { delay ( 1000 ) bob () } } private suspend fun bob (){ } }","title":"Plugin launch"},{"location":"bridge/#plugin-launch-execution-order","text":"It is recommended to use suspendable command executors or suspendable listeners to switch to suspend functions. However, if you use plugin.launch , it is important to understand the execution order. Bukkit and Sponge BungeeCord and Velocity class Foo ( private val plugin : Plugin ) { fun bar () { // Main Thread println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is not suspended when switched to the same suspendable context. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first\" \"I am second\" \"I am third\" \"I am fourth\" \"I am fifth\" As BungeeCord and Velocity do not have a main thread, the execution order is slightly different. class Foo ( private val plugin : Plugin ) { fun bar () { // Any thread println ( \"I am first\" ) val job = plugin . launch { println ( \"I am second\" ) // The context is suspended because it is not known which context was present before. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first\" \"I am third\" \"I am second\" \"I am fourth\" \"I am fifth\" You can actually change this behaviour by passing a different parameter to start . This might be useful for other libraries wanting to use MCCoroutine. class Foo ( private val plugin : Plugin ) { fun bar () { // Any thread println ( \"I am first\" ) val job = plugin . launch ( start = CoroutineStart . UNDISPATCHED ) { println ( \"I am second\" ) // The context is not suspended because start is undispatched. delay ( 1000 ) println ( \"I am fourth\" ) // The context is given back after 1000 milliseconds and continuous here. bob () } // When calling delay the suspendable context is suspended and the original context immediately continuous here. println ( \"I am third\" ) } private suspend fun bob (){ println ( \"I am fifth\" ) } } \"I am first\" \"I am second\" \"I am third\" \"I am fourth\" \"I am fifth\"","title":"Plugin launch execution order"},{"location":"bridge/#do-not-use-runblocking","text":"Using runBlocking in production code is very bad as it annihilates any improvements, we have made by using coroutines. MCCoroutine manipulates the Bukkit Scheduler to allow runBlocking during startup and disable, but plugin.launch{} is almost always the function you want to use instead.","title":"Do not use runBlocking"},{"location":"caching/","text":"Suspending Caches, Background Repeating Tasks This page explains how you can create a lazy-loading cache using Kotlin Coroutines. In minecraft plugins, players can perform many actions in a short time period. If plugins want to keep track of them and store every action in the database, creating a new database call for every single action may cause performance problems. Therefore, caches are often implemented, which is a lot easier when using coroutines. Implementing a Cache (Bukkit) When taking a look at the Database implementation below, we can observe quite a lot of redundant database accesses when a player rejoins a server in a very short timeframe. For this, we put a lazy-loading cache in front of the Database implementation. class Database () { fun createDbIfNotExist () { // ... SQL calls } fun getDataFromPlayer ( player : Player ) : PlayerData { // ... SQL calls } fun saveData ( player : Player , playerData : PlayerData ) { // ... SQL calls } } import kotlinx.coroutines.Deferred import org.bukkit.entity.Player class DatabaseCache ( private val database : Database ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { } } Deferred PlayerData Instead of using the type PlayerData directly, we use the type Deferred , which is the representation of a non-blocking job which has got PlayerData as result. This means we essentially store the job of retrieving data from the database into the cache. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the Deferred job is ready. cache [ player ]!! . await () } } } Implementing cache clearing Clearing the cache is as simple as adding a clear method. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } } Background Repeating Tasks After introducing a cache, we can implement a new suspendable background task to save the cached data every 10 minutes. import com.github.shynixn.mccoroutine.bukkit.launch import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () init { // This plugin.launch launches a new scope in the minecraft server context which can be understood // to be a background task and behaves in a similar way to Bukkit.getScheduler().runTask(plugin, Runnable { }) plugin . launch { // This background task is a repeatable task which in this case is an endless loop. The endless loop // is automatically stopped by MCCoroutine once you reload your plugin. while ( true ) { // Save all cached player data every 10 minutes. for ( player in cache . keys . toTypedArray ()) { database . saveData ( player , cache [ player ]!! . await ()) // Remove player when no longer online if ( ! player . isOnline ) { cache . remove ( player ) } } // Suspending the current context is important in this case otherwise the minecraft thread will only execute this // endless loop as it does not have time to execute other things. Delay gives the thread time to execute other things. delay ( 10 * 60 * 1000 ) // 10 minutes } } } fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"Suspending Caches, Background Repeating Tasks"},{"location":"caching/#suspending-caches-background-repeating-tasks","text":"This page explains how you can create a lazy-loading cache using Kotlin Coroutines. In minecraft plugins, players can perform many actions in a short time period. If plugins want to keep track of them and store every action in the database, creating a new database call for every single action may cause performance problems. Therefore, caches are often implemented, which is a lot easier when using coroutines.","title":"Suspending Caches, Background Repeating Tasks"},{"location":"caching/#implementing-a-cache-bukkit","text":"When taking a look at the Database implementation below, we can observe quite a lot of redundant database accesses when a player rejoins a server in a very short timeframe. For this, we put a lazy-loading cache in front of the Database implementation. class Database () { fun createDbIfNotExist () { // ... SQL calls } fun getDataFromPlayer ( player : Player ) : PlayerData { // ... SQL calls } fun saveData ( player : Player , playerData : PlayerData ) { // ... SQL calls } } import kotlinx.coroutines.Deferred import org.bukkit.entity.Player class DatabaseCache ( private val database : Database ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { } }","title":"Implementing a Cache (Bukkit)"},{"location":"caching/#deferred-playerdata","text":"Instead of using the type PlayerData directly, we use the type Deferred , which is the representation of a non-blocking job which has got PlayerData as result. This means we essentially store the job of retrieving data from the database into the cache. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the Deferred job is ready. cache [ player ]!! . await () } } }","title":"Deferred PlayerData"},{"location":"caching/#implementing-cache-clearing","text":"Clearing the cache is as simple as adding a clear method. import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"Implementing cache clearing"},{"location":"caching/#background-repeating-tasks","text":"After introducing a cache, we can implement a new suspendable background task to save the cached data every 10 minutes. import com.github.shynixn.mccoroutine.bukkit.launch import kotlinx.coroutines.* import org.bukkit.entity.Player import org.bukkit.plugin.Plugin class DatabaseCache ( private val database : Database , private val plugin : Plugin ) { private val cache = HashMap < Player , Deferred < PlayerData >> () init { // This plugin.launch launches a new scope in the minecraft server context which can be understood // to be a background task and behaves in a similar way to Bukkit.getScheduler().runTask(plugin, Runnable { }) plugin . launch { // This background task is a repeatable task which in this case is an endless loop. The endless loop // is automatically stopped by MCCoroutine once you reload your plugin. while ( true ) { // Save all cached player data every 10 minutes. for ( player in cache . keys . toTypedArray ()) { database . saveData ( player , cache [ player ]!! . await ()) // Remove player when no longer online if ( ! player . isOnline ) { cache . remove ( player ) } } // Suspending the current context is important in this case otherwise the minecraft thread will only execute this // endless loop as it does not have time to execute other things. Delay gives the thread time to execute other things. delay ( 10 * 60 * 1000 ) // 10 minutes } } } fun clear () { cache . clear () } suspend fun getDataFromPlayer ( player : Player ): PlayerData { return coroutineScope { if ( ! cache . containsKey ( player )) { // Cache miss, create a new job cache [ player ] = async ( Dispatchers . IO ) { database . getDataFromPlayer ( player ) } } // Await suspends the current context until the value of the ``Deferred`` job is ready. cache [ player ]!! . await () } } }","title":"Background Repeating Tasks"},{"location":"commandexecutor/","text":"Suspending Commandexecutors This page explains how you can use Kotlin Coroutines using the suspend key word for command executors in minecraft plugins. Create the CommandExecutor Bukkit BungeeCord Sponge Velocity Create a traditional command executor but implement SuspendingCommandExecutor instead of CommandExecutor . Please consider, that the return value true is automatically assumed, if the function is suspended in one branch. import com.github.shynixn.mccoroutine.bukkit.SuspendingCommandExecutor import org.bukkit.command.Command import org.bukkit.command.CommandSender import org.bukkit.entity.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { if ( sender !is Player ) { return false } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( sender , playerData ) return true } return false } } Create a traditional command executor but extend from SuspendingCommand instead of Command . import com.github.shynixn.mccoroutine.bungeecord.SuspendingCommand import net.md_5.bungee.api.CommandSender import net.md_5.bungee.api.connection.ProxiedPlayer class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommand ( \"playerdata\" ) { override suspend fun execute ( sender : CommandSender , args : Array < out String > ) { if ( sender !is ProxiedPlayer ) { return } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( sender , playerData ) return } } } Create a traditional command executor but extend from SuspendingCommandExecutor instead of CommandExecutor . Please consider, that the return value CommandResult.success() is automatically assumed, if the function is suspended in one branch. import com.github.shynixn.mccoroutine.sponge.SuspendingCommandExecutor import org.spongepowered.api.command.CommandResult import org.spongepowered.api.command.CommandSource import org.spongepowered.api.command.args.CommandContext import org.spongepowered.api.entity.living.player.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun execute ( src : CommandSource , args : CommandContext ): CommandResult { if ( src !is Player ) { return CommandResult . empty () } if ( args . hasAny ( \"name\" )) { val name = args . getOne < String > ( \"name\" ). get () val playerData = database . getDataFromPlayer ( src ) playerData . name = name database . saveData ( src , playerData ) return CommandResult . success () } return CommandResult . empty () } } There are multiple ways to create command executors in Velocity. MCCoroutine provides extensions for both the SimpleCommand and the BrigadierCommand to allow flexibility. A SimpleCommand can be created by implementing SuspendingSimpleCommand instead of SimpleCommand import com.github.shynixn.mccoroutine.velocity.SuspendingSimpleCommand import com.velocitypowered.api.command.SimpleCommand import com.velocitypowered.api.proxy.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingSimpleCommand { override suspend fun execute ( invocation : SimpleCommand . Invocation ) { val source = invocation . source () if ( source !is Player ) { return } val args = invocation . arguments () if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( source ) playerData . name = name database . saveData ( source , playerData ) return } } } A BrigadierCommand can be executed asynchronously using the executesSuspend extension function. More details below. Register the CommandExecutor Bukkit BungeeCord Sponge Velocity Instead of using setExecutor , use the provided extension method setSuspendingExecutor to register a command executor. Important Do not forget to declare the playerdata command in your plugin.yml. import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents import com.github.shynixn.mccoroutine.bukkit.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { // Minecraft Main Thread } } Instead of using registerCommand , use the provided extension method registerSuspendingCommand to register a command executor. Important Do not forget to declare the playerdata command in your plugin.yml. import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin import com.github.shynixn.mccoroutine.bungeecord.registerSuspendingCommand import com.github.shynixn.mccoroutine.bungeecord.registerSuspendingListener class MCCoroutineSamplePlugin : SuspendingPlugin () { private val database = Database () override suspend fun onEnableAsync () { // BungeeCord Startup Thread database . createDbIfNotExist () proxy . pluginManager . registerSuspendingListener ( this , PlayerDataListener ( database )) proxy . pluginManager . registerSuspendingCommand ( this , PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } Instead of using executor , use the provided extension method suspendingExecutor to register a command executor. import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer import com.github.shynixn.mccoroutine.sponge.registerSuspendingListeners import com.github.shynixn.mccoroutine.sponge.suspendingExecutor import com.google.inject.Inject import org.spongepowered.api.Sponge import org.spongepowered.api.command.args.GenericArguments import org.spongepowered.api.command.spec.CommandSpec import org.spongepowered.api.event.Listener import org.spongepowered.api.event.game.state.GameStartedServerEvent import org.spongepowered.api.event.game.state.GameStoppingServerEvent import org.spongepowered.api.plugin.Plugin import org.spongepowered.api.plugin.PluginContainer import org.spongepowered.api.text.Text @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Inject private lateinit var pluginContainer : PluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread database . createDbIfNotExist () Sponge . getEventManager (). registerSuspendingListeners ( pluginContainer , PlayerDataListener ( database )) val commandSpec = CommandSpec . builder () . description ( Text . of ( \"Command for operations.\" )) . permission ( \"mccoroutine.sample\" ) . arguments ( GenericArguments . onlyOne ( GenericArguments . string ( Text . of ( \"name\" ))) ) . suspendingExecutor ( pluginContainer , PlayerDataCommandExecutor ( database )) Sponge . getCommandManager (). register ( pluginContainer , commandSpec . build (), listOf ( \"playerdata\" )) } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } Instead of using register , use the provided extension method registerSuspend to register a simple command executor. @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject lateinit var proxyServer : ProxyServer @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool database . createDbIfNotExist () proxyServer . eventManager . registerSuspend ( this , PlayerDataListener ( database )) val meta = proxyServer . commandManager . metaBuilder ( \"playerdata\" ). build () // Register SimpleCommand proxyServer . commandManager . registerSuspend ( meta , PlayerDataCommandExecutor ( database ), this ) // Register BrigadierCommand val helloCommand = LiteralArgumentBuilder . literal < CommandSource > ( \"test\" ) . executesSuspend ( this , { context : CommandContext < CommandSource > -> val message = Component . text ( \"Hello World\" , NamedTextColor . AQUA ) context . getSource (). sendMessage ( message ) 1 // indicates success }) . build () proxyServer . commandManager . register ( BrigadierCommand ( helloCommand )) } } Test the CommandExecutor Join your server and use the playerData command to observe getDataFromPlayer and saveData messages getting printed to your server log.","title":"Suspending CommandExecutors"},{"location":"commandexecutor/#suspending-commandexecutors","text":"This page explains how you can use Kotlin Coroutines using the suspend key word for command executors in minecraft plugins.","title":"Suspending Commandexecutors"},{"location":"commandexecutor/#create-the-commandexecutor","text":"Bukkit BungeeCord Sponge Velocity Create a traditional command executor but implement SuspendingCommandExecutor instead of CommandExecutor . Please consider, that the return value true is automatically assumed, if the function is suspended in one branch. import com.github.shynixn.mccoroutine.bukkit.SuspendingCommandExecutor import org.bukkit.command.Command import org.bukkit.command.CommandSender import org.bukkit.entity.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { if ( sender !is Player ) { return false } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( sender , playerData ) return true } return false } } Create a traditional command executor but extend from SuspendingCommand instead of Command . import com.github.shynixn.mccoroutine.bungeecord.SuspendingCommand import net.md_5.bungee.api.CommandSender import net.md_5.bungee.api.connection.ProxiedPlayer class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommand ( \"playerdata\" ) { override suspend fun execute ( sender : CommandSender , args : Array < out String > ) { if ( sender !is ProxiedPlayer ) { return } if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( sender ) playerData . name = name database . saveData ( sender , playerData ) return } } } Create a traditional command executor but extend from SuspendingCommandExecutor instead of CommandExecutor . Please consider, that the return value CommandResult.success() is automatically assumed, if the function is suspended in one branch. import com.github.shynixn.mccoroutine.sponge.SuspendingCommandExecutor import org.spongepowered.api.command.CommandResult import org.spongepowered.api.command.CommandSource import org.spongepowered.api.command.args.CommandContext import org.spongepowered.api.entity.living.player.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingCommandExecutor { override suspend fun execute ( src : CommandSource , args : CommandContext ): CommandResult { if ( src !is Player ) { return CommandResult . empty () } if ( args . hasAny ( \"name\" )) { val name = args . getOne < String > ( \"name\" ). get () val playerData = database . getDataFromPlayer ( src ) playerData . name = name database . saveData ( src , playerData ) return CommandResult . success () } return CommandResult . empty () } } There are multiple ways to create command executors in Velocity. MCCoroutine provides extensions for both the SimpleCommand and the BrigadierCommand to allow flexibility. A SimpleCommand can be created by implementing SuspendingSimpleCommand instead of SimpleCommand import com.github.shynixn.mccoroutine.velocity.SuspendingSimpleCommand import com.velocitypowered.api.command.SimpleCommand import com.velocitypowered.api.proxy.Player class PlayerDataCommandExecutor ( private val database : Database ) : SuspendingSimpleCommand { override suspend fun execute ( invocation : SimpleCommand . Invocation ) { val source = invocation . source () if ( source !is Player ) { return } val args = invocation . arguments () if ( args . size == 2 && args [ 0 ] . equals ( \"rename\" , true )) { val name = args [ 1 ] val playerData = database . getDataFromPlayer ( source ) playerData . name = name database . saveData ( source , playerData ) return } } } A BrigadierCommand can be executed asynchronously using the executesSuspend extension function. More details below.","title":"Create the CommandExecutor"},{"location":"commandexecutor/#register-the-commandexecutor","text":"Bukkit BungeeCord Sponge Velocity Instead of using setExecutor , use the provided extension method setSuspendingExecutor to register a command executor. Important Do not forget to declare the playerdata command in your plugin.yml. import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents import com.github.shynixn.mccoroutine.bukkit.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { // Minecraft Main Thread } } Instead of using registerCommand , use the provided extension method registerSuspendingCommand to register a command executor. Important Do not forget to declare the playerdata command in your plugin.yml. import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin import com.github.shynixn.mccoroutine.bungeecord.registerSuspendingCommand import com.github.shynixn.mccoroutine.bungeecord.registerSuspendingListener class MCCoroutineSamplePlugin : SuspendingPlugin () { private val database = Database () override suspend fun onEnableAsync () { // BungeeCord Startup Thread database . createDbIfNotExist () proxy . pluginManager . registerSuspendingListener ( this , PlayerDataListener ( database )) proxy . pluginManager . registerSuspendingCommand ( this , PlayerDataCommandExecutor ( database )) } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } Instead of using executor , use the provided extension method suspendingExecutor to register a command executor. import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer import com.github.shynixn.mccoroutine.sponge.registerSuspendingListeners import com.github.shynixn.mccoroutine.sponge.suspendingExecutor import com.google.inject.Inject import org.spongepowered.api.Sponge import org.spongepowered.api.command.args.GenericArguments import org.spongepowered.api.command.spec.CommandSpec import org.spongepowered.api.event.Listener import org.spongepowered.api.event.game.state.GameStartedServerEvent import org.spongepowered.api.event.game.state.GameStoppingServerEvent import org.spongepowered.api.plugin.Plugin import org.spongepowered.api.plugin.PluginContainer import org.spongepowered.api.text.Text @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Inject private lateinit var pluginContainer : PluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread database . createDbIfNotExist () Sponge . getEventManager (). registerSuspendingListeners ( pluginContainer , PlayerDataListener ( database )) val commandSpec = CommandSpec . builder () . description ( Text . of ( \"Command for operations.\" )) . permission ( \"mccoroutine.sample\" ) . arguments ( GenericArguments . onlyOne ( GenericArguments . string ( Text . of ( \"name\" ))) ) . suspendingExecutor ( pluginContainer , PlayerDataCommandExecutor ( database )) Sponge . getCommandManager (). register ( pluginContainer , commandSpec . build (), listOf ( \"playerdata\" )) } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } Instead of using register , use the provided extension method registerSuspend to register a simple command executor. @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject lateinit var proxyServer : ProxyServer @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool database . createDbIfNotExist () proxyServer . eventManager . registerSuspend ( this , PlayerDataListener ( database )) val meta = proxyServer . commandManager . metaBuilder ( \"playerdata\" ). build () // Register SimpleCommand proxyServer . commandManager . registerSuspend ( meta , PlayerDataCommandExecutor ( database ), this ) // Register BrigadierCommand val helloCommand = LiteralArgumentBuilder . literal < CommandSource > ( \"test\" ) . executesSuspend ( this , { context : CommandContext < CommandSource > -> val message = Component . text ( \"Hello World\" , NamedTextColor . AQUA ) context . getSource (). sendMessage ( message ) 1 // indicates success }) . build () proxyServer . commandManager . register ( BrigadierCommand ( helloCommand )) } }","title":"Register the CommandExecutor"},{"location":"commandexecutor/#test-the-commandexecutor","text":"Join your server and use the playerData command to observe getDataFromPlayer and saveData messages getting printed to your server log.","title":"Test the CommandExecutor"},{"location":"coroutine/","text":"Kotlin Coroutines and Minecraft Plugins When starting with Coroutines in Kotlin , it is interesting how this can be translated to the world of minecraft plugins. It is recommended to learn how Kotlin Coroutines work before you continue here. Important Make sure you have already installed MCCoroutine. See Installation for details. Starting a coroutine For beginners, it is often confusing how to enter a coroutine. The examples in the official guide mostly use runBlocking because it makes sense for testing. However, keep in mind to never use runblocking in any of your plugins. To enter a coroutine anywhere in your code at any time: fun foo () { plugin . launch { // This will always be on the minecraft main thread. } } Switching coroutine context Later in the Coroutines in Kotlin guide, the terms coroutine-context and dispatchers are explained. A dispatcher determines what thread or threads the corresponding coroutine uses for its execution. Therefore, MCCoroutine offers 2 custom dispatchers: minecraftDispatcher (Allows to execute coroutines on the main minecraft thread) asyncDispatcher (Allows to execute coroutines on the async minecraft threadpool) However, it is recommend to use Dispatchers.IO instead of asyncDispatcher because it is more optimized. An example how this works is shown below: fun foo () { plugin . launch { // This will always be on the minecraft main thread. val result1 = withContext ( plugin . minecraftDispatcher ) { // Perform operations on the minecraft main thread. \"Player is \" // Optionally, return a result. } // Here we are automatically back on the main thread again. val result2 = withContext ( plugin . asyncDispatcher ) { // Perform operations asynchronously. \" Max\" } // Here we are automatically back on the main thread again. println ( result1 + result2 ) // Prints 'Player is Max' } } Normally, you do not need to call plugin.minecraftDispatcher in your code. Instead, you are guaranteed to be always on the minecraft main thread in the plugin.launch{} scope and use sub coroutines (e.g. withContext) to perform asynchronous operations. Such a case can be found below: @EventHandler fun onPlayerJoinEvent ( event : PlayerJoinEvent ) { plugin . launch { // Main Thread val name = event . player . name val listOfFriends = withContext ( Dispatchers . IO ) { // IO Thread val friendNames = Files . readAllLines ( Paths . get ( \" $ name .json\" )) friendNames } // Main Thread val friendText = listOfFriends . joinToString ( \", \" ) event . player . sendMessage ( \"My friends are: $ friendText \" ) } } Coroutines everywhere Using plugin.launch{} is valuable if you migrate existing plugins to use coroutines. However, if you write a new plugin from scratch, you may consider using convenience integrations provided by MCCoroutine such as: Suspending Plugin Suspending Listeners Suspending CommandExecutors","title":"Kotlin Coroutines and Minecraft Plugins"},{"location":"coroutine/#kotlin-coroutines-and-minecraft-plugins","text":"When starting with Coroutines in Kotlin , it is interesting how this can be translated to the world of minecraft plugins. It is recommended to learn how Kotlin Coroutines work before you continue here. Important Make sure you have already installed MCCoroutine. See Installation for details.","title":"Kotlin Coroutines and Minecraft Plugins"},{"location":"coroutine/#starting-a-coroutine","text":"For beginners, it is often confusing how to enter a coroutine. The examples in the official guide mostly use runBlocking because it makes sense for testing. However, keep in mind to never use runblocking in any of your plugins. To enter a coroutine anywhere in your code at any time: fun foo () { plugin . launch { // This will always be on the minecraft main thread. } }","title":"Starting a coroutine"},{"location":"coroutine/#switching-coroutine-context","text":"Later in the Coroutines in Kotlin guide, the terms coroutine-context and dispatchers are explained. A dispatcher determines what thread or threads the corresponding coroutine uses for its execution. Therefore, MCCoroutine offers 2 custom dispatchers: minecraftDispatcher (Allows to execute coroutines on the main minecraft thread) asyncDispatcher (Allows to execute coroutines on the async minecraft threadpool) However, it is recommend to use Dispatchers.IO instead of asyncDispatcher because it is more optimized. An example how this works is shown below: fun foo () { plugin . launch { // This will always be on the minecraft main thread. val result1 = withContext ( plugin . minecraftDispatcher ) { // Perform operations on the minecraft main thread. \"Player is \" // Optionally, return a result. } // Here we are automatically back on the main thread again. val result2 = withContext ( plugin . asyncDispatcher ) { // Perform operations asynchronously. \" Max\" } // Here we are automatically back on the main thread again. println ( result1 + result2 ) // Prints 'Player is Max' } } Normally, you do not need to call plugin.minecraftDispatcher in your code. Instead, you are guaranteed to be always on the minecraft main thread in the plugin.launch{} scope and use sub coroutines (e.g. withContext) to perform asynchronous operations. Such a case can be found below: @EventHandler fun onPlayerJoinEvent ( event : PlayerJoinEvent ) { plugin . launch { // Main Thread val name = event . player . name val listOfFriends = withContext ( Dispatchers . IO ) { // IO Thread val friendNames = Files . readAllLines ( Paths . get ( \" $ name .json\" )) friendNames } // Main Thread val friendText = listOfFriends . joinToString ( \", \" ) event . player . sendMessage ( \"My friends are: $ friendText \" ) } }","title":"Switching coroutine context"},{"location":"coroutine/#coroutines-everywhere","text":"Using plugin.launch{} is valuable if you migrate existing plugins to use coroutines. However, if you write a new plugin from scratch, you may consider using convenience integrations provided by MCCoroutine such as: Suspending Plugin Suspending Listeners Suspending CommandExecutors","title":"Coroutines everywhere"},{"location":"exception/","text":"Exception Handling MCCoroutine implements exception handling as explained by the official Coroutine docs . If an exception is not caught (e.g. an exception is thrown in a suspendable commandexecutor or listener), the exception is propagated upwards to MCCoroutine. Default Exception Behaviour By default, MCCoroutine logs every exception except CoroutineCancellation , which is thrown when a job is cancelled. logger . log ( Level . SEVERE , \"This is not an error of MCCoroutine! See sub exception for details.\" , exception ) Custom Exception Behaviour You can handle exceptions by yourself by listening to the MCCoroutineExceptionEvent . This event is sent to the event bus of the minecraft frame work (e.g. Bukkit, Sponge, BungeeCord) and can be used for logging. The following points should be considered: The event arrives at the main thread (Bukkit, Sponge) The event is also called for CoroutineCancellation Exceptions arrive for every plugin using MCCoroutine. Check if event.plugin equals your plugin. You can cancel the event to disable logging the event with the default exception behaviour You can make this event a suspend function, however put a try-catch over the entire function. Otherwise, any exception which occur while logging the original exception could stack indefinitely which eventually causes a OutOfMemoryException","title":"Exception Handling"},{"location":"exception/#exception-handling","text":"MCCoroutine implements exception handling as explained by the official Coroutine docs . If an exception is not caught (e.g. an exception is thrown in a suspendable commandexecutor or listener), the exception is propagated upwards to MCCoroutine.","title":"Exception Handling"},{"location":"exception/#default-exception-behaviour","text":"By default, MCCoroutine logs every exception except CoroutineCancellation , which is thrown when a job is cancelled. logger . log ( Level . SEVERE , \"This is not an error of MCCoroutine! See sub exception for details.\" , exception )","title":"Default Exception Behaviour"},{"location":"exception/#custom-exception-behaviour","text":"You can handle exceptions by yourself by listening to the MCCoroutineExceptionEvent . This event is sent to the event bus of the minecraft frame work (e.g. Bukkit, Sponge, BungeeCord) and can be used for logging. The following points should be considered: The event arrives at the main thread (Bukkit, Sponge) The event is also called for CoroutineCancellation Exceptions arrive for every plugin using MCCoroutine. Check if event.plugin equals your plugin. You can cancel the event to disable logging the event with the default exception behaviour You can make this event a suspend function, however put a try-catch over the entire function. Otherwise, any exception which occur while logging the original exception could stack indefinitely which eventually causes a OutOfMemoryException","title":"Custom Exception Behaviour"},{"location":"faq/","text":"FAQ This page explains the most common questions regarding MCCoroutine. How is MCCoroutine implemented? MCCoroutine simply wraps the existing schedulers of the minecraft frameworks. For example, when you suspend a function using withContext , MCCoroutine sends new tasks to the Bukkit scheduler if necessary. Every consideration about Bukkit schedulers applies to MCCoroutine as well. Does MCCoroutine need more RAM? MCCoroutine does not create any resources like threads or threadPools. This means MCCoroutine does not have any overhead. However, Kotlin Coroutines contains additional thread pools which may increase memory usage slightly. Take a look the the official Kotlin Coroutine docs for details. Are Suspendable Listeners/Command Executors slower? No, they are as fast as ordinary listeners and command executors. The registration of them is slightly slower because reflection calls are used to create them. Once players join the server and events arrive, they are the same speed. How to cancel all running jobs? You can control the behaviour of the coroutine using plugin.scope . plugin . scope . coroutineContext . cancelChildren () How to cancel suspendable events? The following example is not possible. You cannot cancel events after you have suspended the context for the very first time. The event has already happened, and the outcome has already been decided. @EventHandler suspend fun onPlayerInteractEvent ( event : PlayerInteractEvent ) { withContext ( Dispatchers . IO ){ // e.g. read file/database delay ( 50 ) } // Cancellation is not possible at this point. event . isCancelled = true ; } Cancelling events before the first suspension is still possible. @EventHandler suspend fun onPlayerInteractEvent ( event : PlayerInteractEvent ) { // Cancellation is possible at this point. event . isCancelled = true ; withContext ( Dispatchers . IO ){ // e.g. read file/database delay ( 50 ) } }","title":"FAQ"},{"location":"faq/#faq","text":"This page explains the most common questions regarding MCCoroutine.","title":"FAQ"},{"location":"faq/#how-is-mccoroutine-implemented","text":"MCCoroutine simply wraps the existing schedulers of the minecraft frameworks. For example, when you suspend a function using withContext , MCCoroutine sends new tasks to the Bukkit scheduler if necessary. Every consideration about Bukkit schedulers applies to MCCoroutine as well.","title":"How is MCCoroutine implemented?"},{"location":"faq/#does-mccoroutine-need-more-ram","text":"MCCoroutine does not create any resources like threads or threadPools. This means MCCoroutine does not have any overhead. However, Kotlin Coroutines contains additional thread pools which may increase memory usage slightly. Take a look the the official Kotlin Coroutine docs for details.","title":"Does MCCoroutine need more RAM?"},{"location":"faq/#are-suspendable-listenerscommand-executors-slower","text":"No, they are as fast as ordinary listeners and command executors. The registration of them is slightly slower because reflection calls are used to create them. Once players join the server and events arrive, they are the same speed.","title":"Are Suspendable Listeners/Command Executors slower?"},{"location":"faq/#how-to-cancel-all-running-jobs","text":"You can control the behaviour of the coroutine using plugin.scope . plugin . scope . coroutineContext . cancelChildren ()","title":"How to cancel all running jobs?"},{"location":"faq/#how-to-cancel-suspendable-events","text":"The following example is not possible. You cannot cancel events after you have suspended the context for the very first time. The event has already happened, and the outcome has already been decided. @EventHandler suspend fun onPlayerInteractEvent ( event : PlayerInteractEvent ) { withContext ( Dispatchers . IO ){ // e.g. read file/database delay ( 50 ) } // Cancellation is not possible at this point. event . isCancelled = true ; } Cancelling events before the first suspension is still possible. @EventHandler suspend fun onPlayerInteractEvent ( event : PlayerInteractEvent ) { // Cancellation is possible at this point. event . isCancelled = true ; withContext ( Dispatchers . IO ){ // e.g. read file/database delay ( 50 ) } }","title":"How to cancel suspendable events?"},{"location":"installation/","text":"Getting Started In order to use the MCCoroutine Kotlin API, you need to include the following libraries into your project. Add MCCoroutine Libraries Bukkit BungeeCord Sponge Velocity dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:2.5.0\" ) } dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bungeecord-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bungeecord-core:2.5.0\" ) } dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-sponge-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-sponge-core:2.5.0\" ) } dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-velocity-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-velocity-core:2.5.0\" ) } Add Kotlin Coroutines Libraries MCCoroutine builds against Kotlin 1.3.x, however it does not distribute the Kotlin Runtime or Kotlin Coroutines Runtime. This means, you can use any Kotlin version in your plugins. It is even encouraged to always use the latest version. Replace 1.x.x with the actual versions. dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.x.x\" ) } Shade Dependencies Bukkit Server 1.17 - Latest Other Server plugin.yml libraries : - com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:2.5.0 - com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:2.5.0 Shade the libraries into your plugin.jar file using gradle or maven. Test the Plugin Try to call launch{} in your onEnable() function in your Plugin class. Further help Please take a look at the sample plugins mccoroutine-bukkit-sample or mccoroutine-sponge-sample which can be found on Github . A real production plugin using MCCoroutine can be found here .","title":"Installation"},{"location":"installation/#getting-started","text":"In order to use the MCCoroutine Kotlin API, you need to include the following libraries into your project.","title":"Getting Started"},{"location":"installation/#add-mccoroutine-libraries","text":"Bukkit BungeeCord Sponge Velocity dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:2.5.0\" ) } dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bungeecord-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-bungeecord-core:2.5.0\" ) } dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-sponge-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-sponge-core:2.5.0\" ) } dependencies { implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-velocity-api:2.5.0\" ) implementation ( \"com.github.shynixn.mccoroutine:mccoroutine-velocity-core:2.5.0\" ) }","title":"Add MCCoroutine Libraries"},{"location":"installation/#add-kotlin-coroutines-libraries","text":"MCCoroutine builds against Kotlin 1.3.x, however it does not distribute the Kotlin Runtime or Kotlin Coroutines Runtime. This means, you can use any Kotlin version in your plugins. It is even encouraged to always use the latest version. Replace 1.x.x with the actual versions. dependencies { implementation ( \"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.x.x\" ) }","title":"Add Kotlin Coroutines Libraries"},{"location":"installation/#shade-dependencies","text":"Bukkit Server 1.17 - Latest Other Server plugin.yml libraries : - com.github.shynixn.mccoroutine:mccoroutine-bukkit-api:2.5.0 - com.github.shynixn.mccoroutine:mccoroutine-bukkit-core:2.5.0 Shade the libraries into your plugin.jar file using gradle or maven.","title":"Shade Dependencies"},{"location":"installation/#test-the-plugin","text":"Try to call launch{} in your onEnable() function in your Plugin class. Further help Please take a look at the sample plugins mccoroutine-bukkit-sample or mccoroutine-sponge-sample which can be found on Github . A real production plugin using MCCoroutine can be found here .","title":"Test the Plugin"},{"location":"listener/","text":"Suspending Listeners This page explains how you can use Kotlin Coroutines using the suspend key word for listeners in minecraft plugins. Create the Listener Create a listener and add suspend to all functions where you perform suspendable operations (e.g. calling other suspendable functions). You can mix suspendable and non suspendable functions in listeners. Bukkit BungeeCord Sponge Velocity import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent import org.bukkit.event.player.PlayerQuitEvent import java.util.* class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( event : PlayerJoinEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( event : PlayerQuitEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } In BungeeCord some events can be handled asynchronously . This allows full control over consuming, processing and resuming events when performing long running operations. When you create a suspend function using MCCoroutine, they automatically handle registerIntent and completeIntent . You do not have to do anything yourself, all suspend functions are automatically processed asynchronously. import net.md_5.bungee.api.event.PostLoginEvent import net.md_5.bungee.api.event.ServerDisconnectEvent import net.md_5.bungee.api.plugin.Listener import net.md_5.bungee.event.EventHandler import java.util.* class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( event : PostLoginEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( event : ServerDisconnectEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } import org.spongepowered.api.event.Listener import org.spongepowered.api.event.network.ClientConnectionEvent import java.util.* class PlayerDataListener ( private val database : Database ) { @Listener suspend fun onPlayerJoinEvent ( event : ClientConnectionEvent . Join ) { val player = event . targetEntity val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @Listener suspend fun onPlayerQuitEvent ( event : ClientConnectionEvent . Disconnect ) { val player = event . targetEntity val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } In Velocity events can be handled asynchronously . This allows full control over consuming, processing and resuming events when performing long running operations. When you create a suspend function using MCCoroutine, they automatically handle Continuation and EventTask . You do not have to do anything yourself, all suspend functions are automatically processed asynchronously. import com.velocitypowered.api.event.Subscribe import com.velocitypowered.api.event.connection.DisconnectEvent import com.velocitypowered.api.event.connection.PostLoginEvent import java.util.* class PlayerDataListener ( private val database : Database ) { @Subscribe suspend fun onPlayerJoinEvent ( event : PostLoginEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . username playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @Subscribe suspend fun onPlayerQuitEvent ( event : DisconnectEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . username playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } Register the Listener Bukkit BungeeCord Sponge Velocity Instead of using registerEvents , use the provided extension method registerSuspendingEvents to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) } override suspend fun onDisableAsync () { // Minecraft Main Thread } } Instead of using registerListener , use the provided extension method registerSuspendingListener to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin import com.github.shynixn.mccoroutine.bungeecord.registerSuspendingListener class MCCoroutineSamplePlugin : SuspendingPlugin () { private val database = Database () override suspend fun onEnableAsync () { // BungeeCord Startup Thread database . createDbIfNotExist () proxy . pluginManager . registerSuspendingListener ( this , PlayerDataListener ( database )) } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } Instead of using registerListeners , use the provided extension method registerSuspendingListeners to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer import com.github.shynixn.mccoroutine.sponge.registerSuspendingListeners import com.google.inject.Inject import org.spongepowered.api.Sponge import org.spongepowered.api.event.Listener import org.spongepowered.api.event.game.state.GameStartedServerEvent import org.spongepowered.api.event.game.state.GameStoppingServerEvent import org.spongepowered.api.plugin.Plugin import org.spongepowered.api.plugin.PluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Inject private lateinit var pluginContainer : PluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread database . createDbIfNotExist () Sponge . getEventManager (). registerSuspendingListeners ( pluginContainer , PlayerDataListener ( database )) } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } Instead of using register , use the provided extension method registerSuspend to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer import com.github.shynixn.mccoroutine.velocity.registerSuspend import com.google.inject.Inject import com.velocitypowered.api.event.Subscribe import com.velocitypowered.api.event.proxy.ProxyInitializeEvent import com.velocitypowered.api.plugin.Plugin import com.velocitypowered.api.proxy.ProxyServer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject lateinit var proxyServer : ProxyServer @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool database . createDbIfNotExist () proxyServer . eventManager . registerSuspend ( this , PlayerDataListener ( database )) } } Test the Listener Join and leave your server to observe getDataFromPlayer and saveData messages getting printed to your server log.","title":"Suspending Listeners"},{"location":"listener/#suspending-listeners","text":"This page explains how you can use Kotlin Coroutines using the suspend key word for listeners in minecraft plugins.","title":"Suspending Listeners"},{"location":"listener/#create-the-listener","text":"Create a listener and add suspend to all functions where you perform suspendable operations (e.g. calling other suspendable functions). You can mix suspendable and non suspendable functions in listeners. Bukkit BungeeCord Sponge Velocity import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent import org.bukkit.event.player.PlayerQuitEvent import java.util.* class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( event : PlayerJoinEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( event : PlayerQuitEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } In BungeeCord some events can be handled asynchronously . This allows full control over consuming, processing and resuming events when performing long running operations. When you create a suspend function using MCCoroutine, they automatically handle registerIntent and completeIntent . You do not have to do anything yourself, all suspend functions are automatically processed asynchronously. import net.md_5.bungee.api.event.PostLoginEvent import net.md_5.bungee.api.event.ServerDisconnectEvent import net.md_5.bungee.api.plugin.Listener import net.md_5.bungee.event.EventHandler import java.util.* class PlayerDataListener ( private val database : Database ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( event : PostLoginEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @EventHandler suspend fun onPlayerQuitEvent ( event : ServerDisconnectEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } import org.spongepowered.api.event.Listener import org.spongepowered.api.event.network.ClientConnectionEvent import java.util.* class PlayerDataListener ( private val database : Database ) { @Listener suspend fun onPlayerJoinEvent ( event : ClientConnectionEvent . Join ) { val player = event . targetEntity val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @Listener suspend fun onPlayerQuitEvent ( event : ClientConnectionEvent . Disconnect ) { val player = event . targetEntity val playerData = database . getDataFromPlayer ( player ) playerData . name = player . name playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } } In Velocity events can be handled asynchronously . This allows full control over consuming, processing and resuming events when performing long running operations. When you create a suspend function using MCCoroutine, they automatically handle Continuation and EventTask . You do not have to do anything yourself, all suspend functions are automatically processed asynchronously. import com.velocitypowered.api.event.Subscribe import com.velocitypowered.api.event.connection.DisconnectEvent import com.velocitypowered.api.event.connection.PostLoginEvent import java.util.* class PlayerDataListener ( private val database : Database ) { @Subscribe suspend fun onPlayerJoinEvent ( event : PostLoginEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . username playerData . lastJoinDate = Date () database . saveData ( player , playerData ) } @Subscribe suspend fun onPlayerQuitEvent ( event : DisconnectEvent ) { val player = event . player val playerData = database . getDataFromPlayer ( player ) playerData . name = player . username playerData . lastQuitDate = Date () database . saveData ( player , playerData ) } }","title":"Create the Listener"},{"location":"listener/#register-the-listener","text":"Bukkit BungeeCord Sponge Velocity Instead of using registerEvents , use the provided extension method registerSuspendingEvents to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) } override suspend fun onDisableAsync () { // Minecraft Main Thread } } Instead of using registerListener , use the provided extension method registerSuspendingListener to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin import com.github.shynixn.mccoroutine.bungeecord.registerSuspendingListener class MCCoroutineSamplePlugin : SuspendingPlugin () { private val database = Database () override suspend fun onEnableAsync () { // BungeeCord Startup Thread database . createDbIfNotExist () proxy . pluginManager . registerSuspendingListener ( this , PlayerDataListener ( database )) } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } Instead of using registerListeners , use the provided extension method registerSuspendingListeners to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer import com.github.shynixn.mccoroutine.sponge.registerSuspendingListeners import com.google.inject.Inject import org.spongepowered.api.Sponge import org.spongepowered.api.event.Listener import org.spongepowered.api.event.game.state.GameStartedServerEvent import org.spongepowered.api.event.game.state.GameStoppingServerEvent import org.spongepowered.api.plugin.Plugin import org.spongepowered.api.plugin.PluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Inject private lateinit var pluginContainer : PluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread database . createDbIfNotExist () Sponge . getEventManager (). registerSuspendingListeners ( pluginContainer , PlayerDataListener ( database )) } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } Instead of using register , use the provided extension method registerSuspend to allow suspendable functions in your listener. Please notice, that timing measurements are no longer accurate for suspendable functions. import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer import com.github.shynixn.mccoroutine.velocity.registerSuspend import com.google.inject.Inject import com.velocitypowered.api.event.Subscribe import com.velocitypowered.api.event.proxy.ProxyInitializeEvent import com.velocitypowered.api.plugin.Plugin import com.velocitypowered.api.proxy.ProxyServer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject lateinit var proxyServer : ProxyServer @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool database . createDbIfNotExist () proxyServer . eventManager . registerSuspend ( this , PlayerDataListener ( database )) } }","title":"Register the Listener"},{"location":"listener/#test-the-listener","text":"Join and leave your server to observe getDataFromPlayer and saveData messages getting printed to your server log.","title":"Test the Listener"},{"location":"plugin/","text":"Suspending Plugin This guide explains how Kotlin Coroutines can be used in minecraft plugins in various ways using MCCoroutine. For this, a new plugin is developed from scratch to handle asynchronous and synchronous code. Important Make sure you have already installed MCCoroutine. See Installation for details. Plugin Main class MCCoroutine does not need to be called explicitly in your plugin main class. It is started implicitly when you use it for the first time and disposed automatically when you reload your plugin. Bukkit BungeeCord Sponge Velocity The first decision for Bukkit API based plugins is to decide between JavaPlugin or SuspendingJavaPlugin , which is a new base class extending JavaPlugin . If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingJavaPlugin otherwise use JavaPlugin . import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { override suspend fun onEnableAsync () { // Minecraft Main Thread } override suspend fun onDisableAsync () { // Minecraft Main Thread } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the Bukkit Server implementation in the following way: If a context switch is made, it blocks the entire minecraft main thread until the context is given back. This means, in this method, you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins, which may get enabled in the future, wait until this plugin is enabled. The first decision for BungeeCord API based plugins is to decide between Plugin or SuspendingPlugin , which is a new base class extending Plugin . If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingPlugin otherwise use Plugin . import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin class MCCoroutineSamplePlugin : SuspendingPlugin () { override suspend fun onEnableAsync () { // BungeeCord Startup Thread } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the BungeeCord Server implementation in the following way: If a context switch is made, it blocks the entire bungeecord startup thread until the context is given back. This means, in this method, you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins, which may get enabled in the future, wait until this plugin is enabled. The first decision for Sponge API based plugins is to decide, if you want to call other suspending functions from your plugin class. If so, add a field which injects the type SuspendingPluginContainer . This turns your main class into a suspendable listener. import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } MCCoroutine requires to initialize the plugin coroutine scope manually in your plugin main class. This also allows to call suspending functions in your plugin main class. import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool } } Calling a Database from Plugin Main class Create a class containing properties of data, which we want to store into a database. class PlayerData ( var uuid : UUID , var name : String , var lastJoinDate : Date , var lastQuitDate : Date ) { } Create a class Database , which is responsible to store/retrieve this data into/from a database. Here, it is important that we perform all IO calls on async threads and returns on the minecraft main thread. Bukkit BungeeCord Sponge Velocity import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.bukkit.entity.Player import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). id ) // ... create tables } println ( \"[createDbIfNotExist] End on minecraft thread \" + Thread . currentThread (). id ) } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { println ( \"[getDataFromPlayer] Start on minecraft thread \" + Thread . currentThread (). id ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). id ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on minecraft thread \" + Thread . currentThread (). id ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). id ) // insert or update playerData } println ( \"[saveData] End on minecraft thread \" + Thread . currentThread (). id ) } } Important BungeeCord does not have a main thread or minecraft thread. Instead it operates on different types of thread pools . This means, the thread id is not always the same if we suspend an operation. Therefore, it is recommend to print the name of the thread instead of the id to see which threadpool you are currently on. import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import net.md_5.bungee.api.connection.ProxiedPlayer import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). name ) // ... create tables } println ( \"[createDbIfNotExist] End on bungeecord plugin threadpool \" + Thread . currentThread (). name ) } suspend fun getDataFromPlayer ( player : ProxiedPlayer ) : PlayerData { println ( \"[getDataFromPlayer] Start on any thread \" + Thread . currentThread (). name ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). name ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on bungeecord plugin threadpool \" + Thread . currentThread (). name ) return playerData ; } suspend fun saveData ( player : ProxiedPlayer , playerData : PlayerData ) { println ( \"[saveData] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). name ) // insert or update playerData } println ( \"[saveData] End on bungeecord plugin threadpool \" + Thread . currentThread (). name ) } } import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.spongepowered.api.entity.living.player.Player import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). id ) // ... create tables } println ( \"[createDbIfNotExist] End on minecraft thread \" + Thread . currentThread (). id ) } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { println ( \"[getDataFromPlayer] Start on minecraft thread \" + Thread . currentThread (). id ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). id ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on minecraft thread \" + Thread . currentThread (). id ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). id ) // insert or update playerData } println ( \"[saveData] End on minecraft thread \" + Thread . currentThread (). id ) } } Important Velocity does not have a main thread or minecraft thread. Instead it operates on different types of thread pools . This means, the thread id is not always the same if we suspend an operation. Therefore, it is recommend to print the name of the thread instead of the id to see which threadpool you are currently on. import com.velocitypowered.api.proxy.Player import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ) { println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). name ) // ... create tables } println ( \"[createDbIfNotExist] End on velocity plugin threadpool \" + Thread . currentThread (). name ) } suspend fun getDataFromPlayer ( player : Player ): PlayerData { println ( \"[getDataFromPlayer] Start on any thread \" + Thread . currentThread (). name ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). name ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . username , Date (), Date ()) } println ( \"[getDataFromPlayer] End on velocity plugin threadpool \" + Thread . currentThread (). name ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ) { println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). name ) // insert or update playerData } println ( \"[saveData] End on velocity plugin threadpool \" + Thread . currentThread (). name ) } } Create a new instance of the database and call it in your main class. Bukkit BungeeCord Sponge Velocity import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () } override suspend fun onDisableAsync () { } } import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin class MCCoroutineSamplePlugin : SuspendingPlugin () { private val database = Database () override suspend fun onEnableAsync () { // BungeeCord Startup Thread database . createDbIfNotExist () } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread database . createDbIfNotExist () } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } MCCoroutine requires to initialize the plugin coroutine scope manually in your plugin main class. This also allows to call suspending functions in your plugin main class. import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool database . createDbIfNotExist () } } Test the Plugin Start your server to observe the createDbIfNotExist messages getting printed to your server log. Extend it with real database operations to get familiar with how it works.","title":"Suspending Plugin"},{"location":"plugin/#suspending-plugin","text":"This guide explains how Kotlin Coroutines can be used in minecraft plugins in various ways using MCCoroutine. For this, a new plugin is developed from scratch to handle asynchronous and synchronous code. Important Make sure you have already installed MCCoroutine. See Installation for details.","title":"Suspending Plugin"},{"location":"plugin/#plugin-main-class","text":"MCCoroutine does not need to be called explicitly in your plugin main class. It is started implicitly when you use it for the first time and disposed automatically when you reload your plugin. Bukkit BungeeCord Sponge Velocity The first decision for Bukkit API based plugins is to decide between JavaPlugin or SuspendingJavaPlugin , which is a new base class extending JavaPlugin . If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingJavaPlugin otherwise use JavaPlugin . import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { override suspend fun onEnableAsync () { // Minecraft Main Thread } override suspend fun onDisableAsync () { // Minecraft Main Thread } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the Bukkit Server implementation in the following way: If a context switch is made, it blocks the entire minecraft main thread until the context is given back. This means, in this method, you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins, which may get enabled in the future, wait until this plugin is enabled. The first decision for BungeeCord API based plugins is to decide between Plugin or SuspendingPlugin , which is a new base class extending Plugin . If you want to perform async operations or call other suspending functions from your plugin class, go with the newly available type SuspendingPlugin otherwise use Plugin . import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin class MCCoroutineSamplePlugin : SuspendingPlugin () { override suspend fun onEnableAsync () { // BungeeCord Startup Thread } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } How onEnableAsync works The implementation which calls the onEnableAsync function manipulates the BungeeCord Server implementation in the following way: If a context switch is made, it blocks the entire bungeecord startup thread until the context is given back. This means, in this method, you can switch contexts as you like but the plugin is not considered enabled until the context is given back. It allows for a clean startup as the plugin is not considered \"enabled\" until the context is given back. Other plugins which are already enabled, may or may not already perform work in the background. Plugins, which may get enabled in the future, wait until this plugin is enabled. The first decision for Sponge API based plugins is to decide, if you want to call other suspending functions from your plugin class. If so, add a field which injects the type SuspendingPluginContainer . This turns your main class into a suspendable listener. import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } MCCoroutine requires to initialize the plugin coroutine scope manually in your plugin main class. This also allows to call suspending functions in your plugin main class. import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool } }","title":"Plugin Main class"},{"location":"plugin/#calling-a-database-from-plugin-main-class","text":"Create a class containing properties of data, which we want to store into a database. class PlayerData ( var uuid : UUID , var name : String , var lastJoinDate : Date , var lastQuitDate : Date ) { } Create a class Database , which is responsible to store/retrieve this data into/from a database. Here, it is important that we perform all IO calls on async threads and returns on the minecraft main thread. Bukkit BungeeCord Sponge Velocity import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.bukkit.entity.Player import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). id ) // ... create tables } println ( \"[createDbIfNotExist] End on minecraft thread \" + Thread . currentThread (). id ) } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { println ( \"[getDataFromPlayer] Start on minecraft thread \" + Thread . currentThread (). id ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). id ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on minecraft thread \" + Thread . currentThread (). id ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). id ) // insert or update playerData } println ( \"[saveData] End on minecraft thread \" + Thread . currentThread (). id ) } } Important BungeeCord does not have a main thread or minecraft thread. Instead it operates on different types of thread pools . This means, the thread id is not always the same if we suspend an operation. Therefore, it is recommend to print the name of the thread instead of the id to see which threadpool you are currently on. import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import net.md_5.bungee.api.connection.ProxiedPlayer import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). name ) // ... create tables } println ( \"[createDbIfNotExist] End on bungeecord plugin threadpool \" + Thread . currentThread (). name ) } suspend fun getDataFromPlayer ( player : ProxiedPlayer ) : PlayerData { println ( \"[getDataFromPlayer] Start on any thread \" + Thread . currentThread (). name ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). name ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on bungeecord plugin threadpool \" + Thread . currentThread (). name ) return playerData ; } suspend fun saveData ( player : ProxiedPlayer , playerData : PlayerData ) { println ( \"[saveData] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). name ) // insert or update playerData } println ( \"[saveData] End on bungeecord plugin threadpool \" + Thread . currentThread (). name ) } } import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.spongepowered.api.entity.living.player.Player import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). id ) // ... create tables } println ( \"[createDbIfNotExist] End on minecraft thread \" + Thread . currentThread (). id ) } suspend fun getDataFromPlayer ( player : Player ) : PlayerData { println ( \"[getDataFromPlayer] Start on minecraft thread \" + Thread . currentThread (). id ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). id ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . name , Date (), Date ()) } println ( \"[getDataFromPlayer] End on minecraft thread \" + Thread . currentThread (). id ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on minecraft thread \" + Thread . currentThread (). id ) withContext ( Dispatchers . IO ){ println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). id ) // insert or update playerData } println ( \"[saveData] End on minecraft thread \" + Thread . currentThread (). id ) } } Important Velocity does not have a main thread or minecraft thread. Instead it operates on different types of thread pools . This means, the thread id is not always the same if we suspend an operation. Therefore, it is recommend to print the name of the thread instead of the id to see which threadpool you are currently on. import com.velocitypowered.api.proxy.Player import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import java.util.* class Database () { suspend fun createDbIfNotExist () { println ( \"[createDbIfNotExist] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ) { println ( \"[createDbIfNotExist] Creating database on database io thread \" + Thread . currentThread (). name ) // ... create tables } println ( \"[createDbIfNotExist] End on velocity plugin threadpool \" + Thread . currentThread (). name ) } suspend fun getDataFromPlayer ( player : Player ): PlayerData { println ( \"[getDataFromPlayer] Start on any thread \" + Thread . currentThread (). name ) val playerData = withContext ( Dispatchers . IO ) { println ( \"[getDataFromPlayer] Retrieving player data on database io thread \" + Thread . currentThread (). name ) // ... get from database by player uuid or create new playerData instance. PlayerData ( player . uniqueId , player . username , Date (), Date ()) } println ( \"[getDataFromPlayer] End on velocity plugin threadpool \" + Thread . currentThread (). name ) return playerData ; } suspend fun saveData ( player : Player , playerData : PlayerData ) { println ( \"[saveData] Start on any thread \" + Thread . currentThread (). name ) withContext ( Dispatchers . IO ) { println ( \"[saveData] Saving player data on database io thread \" + Thread . currentThread (). name ) // insert or update playerData } println ( \"[saveData] End on velocity plugin threadpool \" + Thread . currentThread (). name ) } } Create a new instance of the database and call it in your main class. Bukkit BungeeCord Sponge Velocity import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () } override suspend fun onDisableAsync () { } } import com.github.shynixn.mccoroutine.bungeecord.SuspendingPlugin class MCCoroutineSamplePlugin : SuspendingPlugin () { private val database = Database () override suspend fun onEnableAsync () { // BungeeCord Startup Thread database . createDbIfNotExist () } override suspend fun onDisableAsync () { // BungeeCord Shutdown Thread (Not the same as the startup thread) } } import com.github.shynixn.mccoroutine.sponge.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Sponge.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject private lateinit var suspendingPluginContainer : SuspendingPluginContainer @Listener suspend fun onEnable ( event : GameStartedServerEvent ) { // Minecraft Main Thread database . createDbIfNotExist () } @Listener suspend fun onDisable ( event : GameStoppingServerEvent ) { // Minecraft Main Thread } } MCCoroutine requires to initialize the plugin coroutine scope manually in your plugin main class. This also allows to call suspending functions in your plugin main class. import com.github.shynixn.mccoroutine.velocity.SuspendingPluginContainer @Plugin ( id = \"mccoroutinesample\" , name = \"MCCoroutineSample\" , description = \"MCCoroutineSample is sample plugin to use MCCoroutine in Velocity.\" ) class MCCoroutineSamplePlugin { private val database = Database () @Inject constructor ( suspendingPluginContainer : SuspendingPluginContainer ) { suspendingPluginContainer . initialize ( this ) } @Subscribe suspend fun onProxyInitialization ( event : ProxyInitializeEvent ) { // Velocity Thread Pool database . createDbIfNotExist () } }","title":"Calling a Database from Plugin Main class"},{"location":"plugin/#test-the-plugin","text":"Start your server to observe the createDbIfNotExist messages getting printed to your server log. Extend it with real database operations to get familiar with how it works.","title":"Test the Plugin"},{"location":"tasks/","text":"Suspending Delayed, Repeating Tasks This page explains how you can delay and repeat tasks using Kotlin Coroutines. Delaying tasks If you are already in a suspend function, you can simply use delay to delay an execution. Using delay we can delay the current context (e.g. Main Thread) by some milliseconds, to easily delay actions without blocking the server. delay essentially suspends the current context and continuous after the given time. Difference between delay() and Thread.sleep() There is a big difference with delay() and Thread.sleep() . Consult the official Kotlin Coroutines documentation for details, however essentially Thread.sleep() blocks the thread for a given time and delay() suspends the thread for a given time. When a thread is suspended, it can do other work (e.g. server handles other operations like players joining or commands) compared to when a thread is blocked, it cannot do other work (e.g. server appears frozen). suspend fun sayHello () { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } If you are not in a suspend function, use plugin.launch together with delay . fun sayHello () { plugin . launch { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } } Delay Ticks MCCoroutine offers an extension method to use delay together with Bukkit and Sponge ticks. delay ( 1. ticks ) Prefer using delay(1.ticks) when delaying on the minecraft main thread instead of delay(50) . The tick extension function is more accurate than using milliseconds directly. The technical details are explained in this github issue . Repeating tasks If you are already in a suspend function, you can simply use traditional loops with delay to repeat tasks. suspend fun sayHello () { println ( \"Please say hello 10 times every 2 seconds\" ) for ( i in 0 until 10 ) { delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } } If you are not in a suspend function, use plugin.launch together with delay . fun sayHello () { plugin . launch { println ( \"Please say hello 10 times every 2 seconds\" ) for ( i in 0 until 10 ) { delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } } } Creating a Minigame using delay (Bukkit) One example where delay is really useful is when creating minigames. It makes the contract of minigame classes very easy to understand. Let's start by implementing a basic minigame class. The first example shows a countdown in the start function of the minigame. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } } Add a run function to the MiniGame class We can extend the start method to call run which contains a loop to tick the miniGame every 1 second. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } } //... } Add a function to stop the game. An admin should be able to cancel the minigame, which we can implement by a stop function. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } //... } The full MiniGame class: import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } } Connect JavaPlugin, Listener and MiniGame import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent class MiniGameListener ( private val miniGame : MiniGame ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { miniGame . join ( playerJoinEvent . player ) // Just for testing purposes miniGame . start () } } import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents import com.github.shynixn.mccoroutine.bukkit.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () private val miniGame = MiniGame () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) server . pluginManager . registerSuspendingEvents ( MiniGameListener ( miniGame ), this ) } override suspend fun onDisableAsync () { // Minecraft Main Thread } } Test the MiniGame Join your server to observe Minigame messages getting printed to your server log.","title":"Suspending Delayed, Repeating Tasks"},{"location":"tasks/#suspending-delayed-repeating-tasks","text":"This page explains how you can delay and repeat tasks using Kotlin Coroutines.","title":"Suspending Delayed, Repeating Tasks"},{"location":"tasks/#delaying-tasks","text":"If you are already in a suspend function, you can simply use delay to delay an execution. Using delay we can delay the current context (e.g. Main Thread) by some milliseconds, to easily delay actions without blocking the server. delay essentially suspends the current context and continuous after the given time. Difference between delay() and Thread.sleep() There is a big difference with delay() and Thread.sleep() . Consult the official Kotlin Coroutines documentation for details, however essentially Thread.sleep() blocks the thread for a given time and delay() suspends the thread for a given time. When a thread is suspended, it can do other work (e.g. server handles other operations like players joining or commands) compared to when a thread is blocked, it cannot do other work (e.g. server appears frozen). suspend fun sayHello () { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } If you are not in a suspend function, use plugin.launch together with delay . fun sayHello () { plugin . launch { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } }","title":"Delaying tasks"},{"location":"tasks/#delay-ticks","text":"MCCoroutine offers an extension method to use delay together with Bukkit and Sponge ticks. delay ( 1. ticks ) Prefer using delay(1.ticks) when delaying on the minecraft main thread instead of delay(50) . The tick extension function is more accurate than using milliseconds directly. The technical details are explained in this github issue .","title":"Delay Ticks"},{"location":"tasks/#repeating-tasks","text":"If you are already in a suspend function, you can simply use traditional loops with delay to repeat tasks. suspend fun sayHello () { println ( \"Please say hello 10 times every 2 seconds\" ) for ( i in 0 until 10 ) { delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } } If you are not in a suspend function, use plugin.launch together with delay . fun sayHello () { plugin . launch { println ( \"Please say hello 10 times every 2 seconds\" ) for ( i in 0 until 10 ) { delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } } }","title":"Repeating tasks"},{"location":"tasks/#creating-a-minigame-using-delay-bukkit","text":"One example where delay is really useful is when creating minigames. It makes the contract of minigame classes very easy to understand. Let's start by implementing a basic minigame class. The first example shows a countdown in the start function of the minigame. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } }","title":"Creating a Minigame using delay (Bukkit)"},{"location":"tasks/#add-a-run-function-to-the-minigame-class","text":"We can extend the start method to call run which contains a loop to tick the miniGame every 1 second. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } } //... }","title":"Add a run function to the MiniGame class"},{"location":"tasks/#add-a-function-to-stop-the-game","text":"An admin should be able to cancel the minigame, which we can implement by a stop function. import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 //... private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } //... }","title":"Add a function to stop the game."},{"location":"tasks/#the-full-minigame-class","text":"import kotlinx.coroutines.delay import org.bukkit.entity.Player class MiniGame { private var isStarted = false ; private var players = HashSet < Player > () private var remainingTime = 0 fun join ( player : Player ) { if ( isStarted ) { return } players . add ( player ) } suspend fun start () { if ( isStarted ) { return } isStarted = true // This loop represents a traditional repeating task which ticks every 1 second and is called 20 times. for ( i in 0 until 20 ) { sendMessageToPlayers ( \"Game is starting in ${ 20 - i } seconds.\" ) delay ( 1000 ) } // ... Teleport players to game. run () } private suspend fun run () { remainingTime = 300 // 300 seconds while ( isStarted && remainingTime > 0 ) { sendMessageToPlayers ( \"Game is over in ${ remainingTime } seconds.\" ) delay ( 1000 ) remainingTime -- } if ( ! isStarted ) { sendMessageToPlayers ( \"Game was cancelled by external stop.\" ) } isStarted = false // ... Teleport players back to lobby. } fun stop () { if ( ! isStarted ) { return } isStarted = false } private fun sendMessageToPlayers ( message : String ) { players . forEach { p -> p . sendMessage ( message ) } } }","title":"The full MiniGame class:"},{"location":"tasks/#connect-javaplugin-listener-and-minigame","text":"import org.bukkit.event.EventHandler import org.bukkit.event.Listener import org.bukkit.event.player.PlayerJoinEvent class MiniGameListener ( private val miniGame : MiniGame ) : Listener { @EventHandler suspend fun onPlayerJoinEvent ( playerJoinEvent : PlayerJoinEvent ) { miniGame . join ( playerJoinEvent . player ) // Just for testing purposes miniGame . start () } } import com.github.shynixn.mccoroutine.bukkit.SuspendingJavaPlugin import com.github.shynixn.mccoroutine.bukkit.registerSuspendingEvents import com.github.shynixn.mccoroutine.bukkit.setSuspendingExecutor class MCCoroutineSamplePlugin : SuspendingJavaPlugin () { private val database = Database () private val miniGame = MiniGame () override suspend fun onEnableAsync () { // Minecraft Main Thread database . createDbIfNotExist () server . pluginManager . registerSuspendingEvents ( PlayerDataListener ( database ), this ) getCommand ( \"playerdata\" ) !! . setSuspendingExecutor ( PlayerDataCommandExecutor ( database )) server . pluginManager . registerSuspendingEvents ( MiniGameListener ( miniGame ), this ) } override suspend fun onDisableAsync () { // Minecraft Main Thread } }","title":"Connect JavaPlugin, Listener and MiniGame"},{"location":"tasks/#test-the-minigame","text":"Join your server to observe Minigame messages getting printed to your server log.","title":"Test the MiniGame"},{"location":"timings/","text":"Timing Measurements (This site is only relevant for Spigot, Paper and CraftBukkit) It is often the case, that we want to measure performance using timings https://timings.spigotmc.org/. However, Coroutines do not yield a meaningful task name per default e.g. Task: CancellableContinuationImpl(Single) , which makes it hard to debug for performance problems. As a solution, it is possible to pass an instance of CoroutineTimings , which is used to give the coroutine and its main thread tasks one meaningful name. For example, if you are starting a new coroutine like this: plugin . launch { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } Change it to the following: plugin . launch ( plugin . minecraftDispatcher + object : CoroutineTimings () {}) { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } Command Executors You can also assign a name to a SuspendingCommandExecutor . For this, add an object called coroutineTimings to your class implementing SuspendingCommandExecutor . class MyCommandExecutor : SuspendingCommandExecutor { // Reference used for naming. companion object coroutineTimings : CoroutineTimings () override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { TODO ( \"Not yet implemented\" ) } } Register the SuspendingCommandExecutor in your plugin class as follows: val myCommandExecutor = MyCommandExecutor () this . getCommand ( \"mycommand\" ) !! . setSuspendingExecutor ( minecraftDispatcher + MyCommandExecutor . coroutineTimings , myCommandExecutor ) Events Event measurements are currently not supported by MCCoroutine. You can temporarily remove suspend from your event method, use plugin.launch(plugin.minecraftDispatcher + object : CoroutineTimings() {}) {} , measure the time and then readd suspend again.","title":"Timing Measurements"},{"location":"timings/#timing-measurements","text":"(This site is only relevant for Spigot, Paper and CraftBukkit) It is often the case, that we want to measure performance using timings https://timings.spigotmc.org/. However, Coroutines do not yield a meaningful task name per default e.g. Task: CancellableContinuationImpl(Single) , which makes it hard to debug for performance problems. As a solution, it is possible to pass an instance of CoroutineTimings , which is used to give the coroutine and its main thread tasks one meaningful name. For example, if you are starting a new coroutine like this: plugin . launch { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) } Change it to the following: plugin . launch ( plugin . minecraftDispatcher + object : CoroutineTimings () {}) { println ( \"Please say hello in 2 seconds\" ) delay ( 2000 ) // Delay for 2000 milliseconds println ( \"hello\" ) }","title":"Timing Measurements"},{"location":"timings/#command-executors","text":"You can also assign a name to a SuspendingCommandExecutor . For this, add an object called coroutineTimings to your class implementing SuspendingCommandExecutor . class MyCommandExecutor : SuspendingCommandExecutor { // Reference used for naming. companion object coroutineTimings : CoroutineTimings () override suspend fun onCommand ( sender : CommandSender , command : Command , label : String , args : Array < out String > ): Boolean { TODO ( \"Not yet implemented\" ) } } Register the SuspendingCommandExecutor in your plugin class as follows: val myCommandExecutor = MyCommandExecutor () this . getCommand ( \"mycommand\" ) !! . setSuspendingExecutor ( minecraftDispatcher + MyCommandExecutor . coroutineTimings , myCommandExecutor )","title":"Command Executors"},{"location":"timings/#events","text":"Event measurements are currently not supported by MCCoroutine. You can temporarily remove suspend from your event method, use plugin.launch(plugin.minecraftDispatcher + object : CoroutineTimings() {}) {} , measure the time and then readd suspend again.","title":"Events"}]}